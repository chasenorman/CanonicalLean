import Lean

open Lean Meta Expr Name

namespace Canonical

def UNFOLD_HARD_CODE : NameSet := .ofList [
  `Set.instMembership, `Set.Mem, `setOf, `instLENat
]

/-- The arity of a function symbol and the arity of its parameters, recursively. -/
structure Arity where
  params : Array Arity := #[]
deriving Inhabited

/-- The `Arity` of a type `e`.
    Should be performed in `withArityUnfold` for consistent results. -/
partial def typeArity (e : Expr) : MetaM Arity := do
  forallTelescopeReducing e fun xs _ => do
    pure ⟨← xs.mapM fun param => do
      let id := param.fvarId!
      pure (← typeArity (← id.getType))⟩

/-- The number of parameters in type `e`. -/
partial def typeArity1 (e : Expr) : MetaM Nat := do
  forallTelescopeReducing e fun xs _ => return xs.size

/-- Indicator for STAR type. -/
@[reducible] def STAR (α : Sort u) : Sort u := α

/-- Given a head symbol `Expr`, returns a `Name` for serializing and its type. -/
def toHead : Expr → MetaM (Name × Expr)
| fvar id =>
  return (id.name.updatePrefix (← id.getUserName).getRoot, ← id.getType)
| mvar id =>
  return (((← getMCtx).getDecl id).userName, ← id.getType)
| sort l =>
  return (`Sort, .sort (l.succ))
| const name us =>
  return (name, (← getConstInfo name).instantiateTypeLevelParams us)
| lit l =>
  let name : Name := match l with
  | .natVal n => .num .anonymous n
  | .strVal s => .str .anonymous s!"\"{s}\""
  return (name, l.type)
| _ => unreachable!

def toNameString (e : Expr) : MetaM String := return (← toHead e).1.toString

/-- Determines whether something of type `e` can accept an argument.
    Should be performed in `withArityUnfold` for consistent results. -/
partial def hidesForall (e : Expr) : MetaM Bool := do
  match ← whnf e with
  | .lam name type body info =>
    withLocalDecl name info type fun fvar => hidesForall (body.instantiate1 fvar)
  | .forallE _ _ _ _ => pure true
  | _ => pure false

/-- `canUnfold` predicate for `withArityUnfold`, unfolding constants that hide a `forallE`. -/
def canUnfold (monomorphize : Bool) (cfg : Config) (info : ConstantInfo) : CoreM Bool := do
  match cfg.transparency with
  | .all => return true
  | .default => return !(← isIrreducible info.name)
  | m =>
    let env ← getEnv
    if (← isReducible info.name) || (UNFOLD_HARD_CODE.contains info.name)
      || (Compiler.getInlineAttribute? env info.name matches .some .inline) then
      return true
    -- If `monomorphize`, we only reduce `OfNat` instances.
    else if m == .instances && isGlobalInstance env info.name &&
      (!monomorphize || (← (isClass? (info.type)).run' {}) == some `OfNat || info.name.getPrefix == `Set) then
      return true
    else if let some value := info.value? then
      return ← (hidesForall value).run' {}
    else return false

/-- Whether `e` contains a recursor or auxiliary recursor. -/
def isRecursive (e : Expr) : MetaM Bool := do
  let env ← getEnv
  return e.getUsedConstants.any fun c =>
    (env.find? c).get! matches .recInfo _ || isAuxRecursor env c

/-- A natural number as expressed as an application of constructors. -/
def rawRawNatLit : Nat → Expr
| 0 => .const ``Nat.zero []
| n + 1 => .app (.const ``Nat.succ []) (rawRawNatLit n)

variable [MonadControlT MetaM n] [Monad n]

/-- Guarantees consistent (static) arity. -/
@[inline] def withArityUnfold (monomorphize : Bool) (e : n α) : n α :=
  withReducibleAndInstances (withCanUnfoldPred (canUnfold monomorphize) e)

/-- `dbg_trace` is not visible in the event of a crash or infinite loop. -/
def printForce (s : String) : IO Unit := do
  let handle ← IO.FS.Handle.mk "output.txt" IO.FS.Mode.append
  handle.putStrLn s
  handle.flush

/-- Pretty printing options for proofs generated by Canonical. -/
def applyOptions : Options → Options :=
  (pp.proofs.set · true |>
  (pp.motives.all.set · true |>
  (pp.unicode.fun.set · true |>
  (pp.letVarTypes.set · true))))

def dneg (Goal : Sort u) (destruct : (Destruct : STAR (Sort u)) → (Goal → Destruct) → Destruct) : Goal :=
  destruct Goal fun a ↦ a

def identity (name : Name) (e : Expr) : Expr := .lam name e (.bvar 0) .default

def apply (e : Expr) (args : List Expr) : Expr :=
  match args with
  | [] => e
  | arg :: args => match e with
    | .lam _name _type body _info =>
      apply (body.instantiate1 arg) args
    | _ => panic! "apply: expected a lambda, got {e}"
