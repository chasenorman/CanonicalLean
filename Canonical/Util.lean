import Lean

open Lean Meta Expr Name

namespace Canonical

def UNFOLD_HARD_CODE : NameSet := .ofList [
  `Set.instMembership, `Set.Mem, `setOf, `instLENat
]

/-- The arity of a function symbol and the arity of its parameters, recursively. -/
structure Arity where
  params : Array Arity := #[]
deriving Inhabited

/-- The `Arity` of a type `e`.
    Should be performed in `withArityUnfold` for consistent results. -/
partial def typeArity (e : Expr) : MetaM Arity := do
  forallTelescopeReducing e fun xs _ => do
    pure ⟨← xs.mapM fun param => do
      let id := param.fvarId!
      pure (← typeArity (← id.getType))⟩

/-- The number of parameters in type `e`. -/
partial def typeArity1 (e : Expr) : MetaM Nat := do
  forallTelescopeReducing e fun xs _ => return xs.size

/-- Given a head symbol `Expr`, returns a `Name` for serializing and its type. -/
def toHead : Expr → MetaM (Name × Expr)
| fvar id =>
  return (id.name.updatePrefix (← id.getUserName).getRoot, ← id.getType)
| mvar id =>
  return (((← getMCtx).getDecl id).userName, ← id.getType)
| sort l =>
  return (`Sort, .sort (l.succ))
| const name us =>
  return (name, (← getConstInfo name).instantiateTypeLevelParams us)
| lit l =>
  let name : Name := match l with
  | .natVal n => .num .anonymous n
  | .strVal s => .str .anonymous s!"\"{s}\""
  return (name, l.type)
| _ => unreachable!

def toNameString (e : Expr) : MetaM String := return (← toHead e).1.toString

/-- Determines whether something of type `e` can accept an argument.
    Should be performed in `withArityUnfold` for consistent results. -/
partial def hidesForall (e : Expr) : MetaM Bool := do
  match ← whnf e with
  | .lam name type body info =>
    withLocalDecl name info type fun fvar => hidesForall (body.instantiate1 fvar)
  | .forallE _ _ _ _ => pure true
  | _ => pure false

/-- `canUnfold` predicate for `withArityUnfold`, unfolding constants that hide a `forallE`. -/
def canUnfold (monomorphize : Bool) (cfg : Config) (info : ConstantInfo) : CoreM Bool := do
  match cfg.transparency with
  | .all => return true
  | .default => return !(← isIrreducible info.name)
  | m =>
    if (← isReducible info.name) || (UNFOLD_HARD_CODE.contains info.name) then
      return true
    -- If `monomorphize`, we only reduce `OfNat` instances.
    else if m == .instances && isGlobalInstance (← getEnv) info.name &&
      (!monomorphize || (← (isClass? (info.type)).run' {}) == some `OfNat) then
      return true
    else if let some value := info.value? then
      return ← (hidesForall value).run' {}
    else return false

/-- Whether `e` contains a recursor or auxiliary recursor. -/
def isRecursive (e : Expr) : MetaM Bool := do
  let env ← getEnv
  return e.getUsedConstants.any fun c =>
    (env.find? c).get! matches .recInfo _ || isAuxRecursor env c

/-- A natural number as expressed as an application of constructors. -/
def rawRawNatLit : Nat → Expr
| 0 => .const ``Nat.zero []
| n + 1 => .app (.const ``Nat.succ []) (rawRawNatLit n)

variable [MonadControlT MetaM n] [Monad n]

/-- Guarantees consistent (static) arity. -/
@[inline] def withArityUnfold (monomorphize : Bool) (e : n α) : n α :=
  withReducibleAndInstances (withCanUnfoldPred (canUnfold monomorphize) e)

/-- `dbg_trace` is not visible in the event of a crash or infinite loop. -/
def printForce (s : String) : IO Unit := do
  let handle ← IO.FS.Handle.mk "output.txt" IO.FS.Mode.append
  handle.putStrLn s
  handle.flush

/-- Pretty printing options for proofs generated by Canonical. -/
def applyOptions : Options → Options :=
  (pp.proofs.set · true |>
  (pp.motives.all.set · true |>
  (pp.coercions.set · false |>
  (pp.unicode.fun.set · true))))
